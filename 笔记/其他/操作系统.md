​                                                                                                                                                                                                                  

设在内存中有三道程序A、B和C，并按A、B、C的优先次序运行，其内部计算和I/O 操作的时间由图 1.15 给出。要求： 

![image-20220302000214786](img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220302000214786.png)

1. 试画出按多道程序运行的时间关系图(调度程序的执行时间忽略不计)，完成这三道程序共花多少时间? 比单道运行节省多少时间?

   ![image-20220302001536342](img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220302001536342.png)

2) 若处理机调度程序每次进行程序状态转换的时间为1ms，试画出在处理机调度程序管理下各程序状态转换的时间关系图。



# 进程管理

## 进程的调度状态

状态转换图

![image-20220301223946812](img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220301223946812.png)



## 进程的调度算法

| 进程 | 到达时间 | 执行时间 |
| ---- | -------- | -------- |
| P1   | 0        | 8        |
| P2   | 1        | 4        |
| P3   | 2        | 9        |
| P4   | 3        | 5        |

-  先来先服务（FCFS）

  | 进程 | 到达时间 | 执行时间 | 开始时间 | 结束时间 | 等待时间 | 周转时间 | 带权周转时间 |
  | ---- | -------- | -------- | -------- | -------- | -------- | -------- | ------------ |
  | P1   | 0        | 8        | 0        | 8        | 0        | 8        |              |
  | P2   | 1        | 4        | 8        | 12       | 7        | 11       |              |
  | P3   | 2        | 9        | 12       | 21       | 10       | 19       |              |
  | P4   | 3        | 5        | 21       | 26       | 18       | 23       |              |

  周转时间：等待时间+运行时间

  带权周转时间：周转时间/运行时间

  

- 短作业优先算法(SJF)

  进程越短越先 

  

  | 进程 | 到达时间 | 执行时间 | 开始时间 | 结束时间 | 等待时间 | 周转时间 | 带权周转时间 |
  | ---- | -------- | -------- | -------- | -------- | -------- | -------- | ------------ |
  | P1   | 0        | 8        | 0        | 8        | 0        | 8        |              |
  | P2   | 1        | 4        | 8        | 12       | 7        | 11       |              |
  | P3   | 2        | 9        | 17       | 26       | 15       | 24       |              |
  | P4   | 3        | 5        | 12       | 17       | 9        | 14       |              |

  

- 高响应比优先调度算法（HRRN）*

  周转时间：等待时间+运行时间

  计算权重：周转时间/执行时间



## 银行家算法

系统有5个进程，系统总资源为（10，5，7），在T0时资源如下。提供安全序列

| 进程 | 进程所需资源 | 已经分配资源 | 还需要的资源 |
| ---- | ------------ | ------------ | ------------ |
| P0   | （7，5，3）  | （0，1，0）  | （7，4，3）  |
| P1   | （3，2，2）  | （2，0，0）  | （1，2，2）  |
| P2   | （9，0，2）  | （3，0，2）  | （6，0，0）  |
| P3   | （2，2，2）  | （2，1，1）  | （0，1，1）  |
| P4   | （4，3，3）  | （0，0，2）  | （4，3，1）  |

计算总共分配的资源：（7，2，5）

可以提供的资源：（10，5，7）-（7，2，5）= （3，3，2）



用这个资源来查看可以满足哪个进程，如果有多个就随机选一个

选择P1

| 进程 | 系统还剩下的资源 | 所需的资源  | 已经分配的资源 | 工作完可以释放的资源                |
| ---- | ---------------- | ----------- | -------------- | ----------------------------------- |
| P1   | （3，3，2）      | （1，2，2） | （2，0，0）    | （3，3，2）+（2，0，0）=（5，3，2） |
|      |                  |             |                |                                     |
|      |                  |             |                |                                     |
|      |                  |             |                |                                     |
|      |                  |             |                |                                     |



## 生产者消费者

## 读者写者



## 死锁

m>=n(w-1)+1是不会发生死锁的条件

m是同类资源量

n是进程数

w是最大需求量







## 资源分配图化简

每次化简的时候，从一个进程看，看自己请求的资源是否得到了满足

如果阻塞的话就看下一个，知道全部遍历完



![image-20220305223708420](img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220305223708420.png)



无死锁

















# PV操作



设有n个进程共享一个互斥段，对于如下两种情况：

(1) 如果每次只允许一个进程进入互斥段；

(2) 如果最多允许m个进程(m<n)同时进入互斥段。

试问：所采用的互斥信号量初值是否相同? 信号量值的变化范围如何?

(1)互斥信号量初值为 1 ，最小值就是被所有进程都抢了一份，也就是1-n，所以范围是[1-n,1]

(2)初值为 m，范围是[m-n,m]









## 阅览室问题

有一个阅览室，共有50个座位，读者进入时必须先在一张登记表上登记，该表为每一座位列一表目，包括座号和读者姓名等，读者离开时要消掉登记的信息，试问：
(1)为描述读者的动作，应编写几个程序，设置几个进程?
(2)试用PV操作描述读者进程之间的同步关系。



```pseudocode
设私有信号量seats为阅览室的空座位数，初值为50；私有信号量readers为阅览室里的读者数，初值为0；公用信号量mutex，初值为1。

#进入阅览室
while(TRUE){
    P (seats); /*没有座位则在室外等候*/
    P（mutex） /*有空位则进入临界区*/
    填写登记表;
    进入阅览室读书;
    V（mutex） /*离开临界区*/
    V（readers）
}

#读者离开阅览室
while(TRUE){
    P（readers） /*阅览室是否有人读书*/
    P（mutex） /*进入临界区*/
    撤销登记；
    离开阅览室；
    V（mutex） /*离开临界区*/
    V（seats） /*释放一个座位资源*/
}
```







## 进程并发

 设有三个并发进程R、M、P，它们共享一个缓冲区。R负责从输入设备读信息，每读一个记录后，就把它存放在缓冲区中；M在缓冲区中加工读入的记录；P把加工后的记录打印输出。读入的记录经加工输出后，缓冲区又可存放下一个记录。试写出它们能正确执行的程序。

```pseudocode
mutex = 1

#R
while(true){

}
```



## 放苹果

桌上有一只盘子，每次只能放入一个水果。爸爸专向盘中放苹果，妈妈专向盘中放桔子，一个女儿专等吃盘中的苹果，一个儿子专等吃盘中的桔子。试用P、V操作写出他们能同步的程序



```pseudocode
empty = 1; mutex = 1; apple = 0;  orange = 0;
father(){
    while(true){
        P(empty)
        P(mutex)
        放苹果
        V(mutex)
        V(apple)
    }
}

dauter(){
    while(true){
        P(apple)
        P(mutex)
        吃苹果
        V(mutex)
        V(empty)
    }
}
```



## 黑白棋

在一盒子里，混装了数量相等的围棋白子和黑子。现在要用自动分拣系统把白子和黑子分开。该系统设有两个进程：P1 和P2，其中P1 将拣白子，P2 将拣黑子。规定每个进程每次只拣一子。当一进程正在拣子时，不允许另一进程去拣；当一进程拣了一子时，必须让另一进程去拣。试写出两个并发进程能正确执行的程序。

```pseudocode
p1 = 1  
p2 = 0 

#黑
while(true){
	P(p1)
	下黑棋
	V(p2)
}


#白
while(true){
	P(p2)
	下白棋
	V(p1)
}
```



# 4储存管理

## 计算物理地址

某进程物理地址有4页，每页2048字节

页表如下：

| 页号 | 块号 |
| ---- | ---- |
| 0    | 2    |
| 1    | 4    |
| 2    | 6    |
| 3    | 8    |

计算4865对应的物理地址



1. 求页号

   4865÷2048=2........769

2. 找到块号，2对应的是6

3. 计算地址

   6*2048+769 = 13057

## 计算物理地址

存储器有32个页。每页1kb，内存64kb，页号和物理块号对应表，计算逻辑地址OA5D的物理地址

页号2对应块号4

1. 将十六进制转为2进制

   00010 1001011101

   因为1kb是2的10次方，所以后面10位是逻辑偏移，前面是页号

   00010就是2

2. 页号变块号，找到2对应的4

3. 偏移直接照抄，然后把块号转为2进制，因为内存64kb，所以是16次方，凑齐16位

   000100 1001011101

## 缺页与页面置换

在一个请求分页系统中，假如页面走向为P=4  3  2  1  4  3  5  4  3  2  1  5，主存容量为M=3，F为是否缺页



- 先进先出(FIFO)算法

|      |      |          |                 |                 |                 |                 |                 |                 |                 |                 |                 |                 |
| ---- | ---- | -------- | --------------- | --------------- | --------------- | --------------- | --------------- | --------------- | --------------- | --------------- | --------------- | --------------- |
| P    | 4    | 3        | 2               | 1               | 4               | 3               | 5               | 4               | 3               | 2               | 1               | 5               |
| M    | 4    | 3<br />4 | 2<br />3<br />4 | 1<br />2<br />3 | 4<br />1<br />2 | 3<br />4<br />1 | 5<br />3<br />4 | 5<br />3<br />4 | 5<br />3<br />4 | 2<br />5<br />3 | 1<br />2<br />5 | 1<br />2<br />5 |
| F    | 是   | 是       | 是              | 是              | 是              | 是              | 是              |                 |                 | 是              | 是              |                 |

每次要是进来的页不在主存，就会缺页，要是主存满的话就会剔除最先进来的

- 最久未使用算法 

  每次删除最久没有被使用的页

|      |      |          |                 |                 |                 |                 |                 |                 |                 |                 |                 |                 |
| ---- | ---- | -------- | --------------- | --------------- | --------------- | --------------- | --------------- | --------------- | --------------- | --------------- | --------------- | --------------- |
| P    | 4    | 3        | 2               | 1               | 4               | 3               | 5               | 4               | 3               | 2               | 1               | 5               |
| M    | 4    | 3<br />4 | 2<br />3<br />4 | 1<br />2<br />3 | 4<br />1<br />2 | 3<br />4<br />1 | 5<br />3<br />4 | 5<br />3<br />4 | 5<br />3<br />4 | 2<br />3<br />4 | 1<br />2<br />3 | 5<br />1<br />2 |
| F    | 是   | 是       | 是              | 是              | 是              | 是              | 是              |                 |                 | 是              | 是              | 是              |





## 计算内存地址

某段式存储管理如下表

| 段号 | 段的长度（字节） | 主存起始地址 |
| ---- | ---------------- | ------------ |
| 0    | 660              | 219          |
| 1    | 14               | 3300         |
| 2    | 100              | 90           |
| 3    | 580              | 1237         |
| 4    | 96               | 1952         |

（1）计算物理地址[0,430]  [1,10]   [2,500]  [3,400]的内存地址

1. 数组第一个元素就是段号，第二个是段内地址
2. 根据段号找到对应的数据然后判断当前段内地址有没有比段内长度长，长的话就说明越界
3. 没有越界的话，就用加主存起始地址就行了

  

[0,430]  ：430+219 = 649

[1,10]：10+3300

[2,500] ：500>100 越界

[3,400]：400+1237 = 1637







访问段表就一次访问内存，（就是我一次就找到，段表就有我需要访问的，就比如我需要段号为0的，段表有，直接找段表，如果段表没有，还要再去找内存，这样就次数多了，题目说最少，所以这个一次），还有存取的时候，我需要对主存操作，所以这个有一次，所以至少2次







# 6 输入输出系统

一个磁盘有150个柱面，读写头在90号柱面上面，一个磁盘队列到达顺序为35，52，37，17，80，120，135，104，计算寻道长度和顺序

- FCFS

  90，35，52，37，17，80，120，135，104

  寻道长度：（90-35）+（52-35）+（52-37）+（37-17）。。。

- SSTF

  首先将上面的序列排序

  17，35，37，52，80，**90**，104，120，135

  按照磁头距离其他位置的距离来寻道

  90，80，104，120，135，52，37，35，17

- SCAN

  向左

  17，35，37，52，80，**90**，104，120，135

  

  
  
  
  
  90，80，52，37，35，17，104，120，135
  
  



## 磁盘记录优化

（1）如果磁盘转一圈20ms，每次读完数据处理数据需要4ms，那么处理完这些数据需要多久？

| 块号       | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
| ---------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **记录号** | A    | B    | C    | D    | E    | F    | G    | H    | I    | J    |

首先转一圈20ms，一共有10个数据，也就是说读完一个数据需要2ms。

首先读A，读完A需要2ms，然后处理数据4ms，处理完之后，指针已经到了4了。此时已经过去了6ms。

然后继续等磁头转到B，此时距离B有8个间隔，也就是8*2 = 16ms，然后处理完B的数据需要读取2ms，处理4ms，之后就是一样的了。总共花费16+2+4 = 22ms。

总共6+22*9= 204ms



（2）如何优化？

在D的位置放B，然后G的位置放C，保证每次处理完数据能够立刻继续处理。		





