# 补码加减法

A=-3/16 B=9/32 

求A+B



A=-87 B=53

求A-B





溢出判断，

溢出用OF（overflow）表示：**当OF=1时溢出；OF=0时，未溢出**

m表示符号位是否进位（进位为1，否则为0）
n表示最高数值位是否进位（进位为1，否则为0）

当：m异或n=1，说明溢出，否则未溢出



![在这里插入图片描述](img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjEwNjE0,size_16,color_FFFFFF,t_70.png)

这里数值位进位了，符号位也是，所以1异或1=0，没有溢出

# 原码一位乘

![image-20220302215224170](img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220302215224170.png)





# 补码一位乘



![image-20220302215324353](img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220302215324353.png)





# 原码一位除（加减交替法）

![image-20220305201119400](img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220305201119400.png)





# 补码的加减交替法



# 浮点数转换

27.25变为IEEE754

27.25 = 100101.01

然后=1.0010101*2^5

符号位1，指数为127+5，剩下的是数据位



浮点数：1符号位 8位符号 剩下的32-8-1=23是数据

![image-20220303152618189](img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220303152618189.png)





# 设计电路



3.1.设CPU共有16根地址线，8根数据线，

2^16 B  8位1B

2^6 KB =64KB cpu大小 选（要求4k，最好8位）

并用![img](file:///C:\Users\闫辰祥\AppData\Local\Temp\ksohtml\wps9BB5.tmp.png)（低电平有效）作访存控制信号，![img](file:///C:\Users\闫辰祥\AppData\Local\Temp\ksohtml\wps9BB6.tmp.png)作读写命令信号（高电平为读，低电平为写）。现有下列存储芯片：ROM（2K×8位，4K×4位（优先选K），8K×8位），RAM（1K×4位，2K×8位，4K×8位），及74138译码器和其他门电路（门电路自定）。试从上述规格中选用合适芯片，画出CPU和存储芯片的连接图。要求：

（1）最小4K地址为系统程序区，4096~16383地址范围为用户程序区。（2^12）

（2）指出选用的存储芯片类型及数量。

（3）详细画出片选逻辑。



- 数据线8根，所以是8位
- 系统程序区就是ROM，所以是4k*8位
- 用户区就是RAM，范围一减是12k，所以是12k*8位
- 在选的时候优先选k匹配的，ROM是4k*8所以找4K\*4的，位数此时不够，所以需要位扩展。两片ROM
- RAM虽然位够了，但是人家是12k，这个最大只有4k，所以是字节扩展。需要三个RAM

![image-20220304143335831](img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220304143335831.png)























# 设计主存地址



注意一点就行，就是**单位统一！**！！！！！！！！！！！

如果没有说，那么默认字节编址，也就是8bit，如果题目说了按字编址，那就全部转换为字的长度

比如说这个：主存容量为512K×16位，Cache容量为4096×16位，块长为4个16位的字

全都是字的长度

## 1

主存256KB，cache2KB，一个字块8个字，一个字8位

（1）直接映射7 8 3

（2）二路组相联 8 7 3

（3）全相联 15 3



（4）若主存为256K*16，在四路组相联下  10 6 3



（5）CPU依次从0，1，2，，，99读取100个数据，重复10次，问命中率和系统效率

命中率：100/8=12...4，进位为13. $(100*10-13)/(100*10)$ = 0.987

系统效率：主存的时间/平均时间

## 2

设主存容量为256K字，Cache容量为2K字，块长为4。

（1）设计Cache地址格式，Cache中可装入多少块数据？9-2

| Cache字块地址（9位） | 字块内地址（2位） |
| -------------------- | ----------------- |

（2）在直接映射方式下，设计主存地址格式。7-9-2

| 主存字块标记（7位） | Cache字块地址（9位） | 字块内地址（2位） |
| ------------------- | -------------------- | ----------------- |

（3）在四路组相联映射方式下，设计主存地址格式。9-7-2



（4）在全相联映射方式下，设计主存地址格式。16-2

（5）若存储字长为32位，存储器按字节寻址，写出上述三种映射方式下主存的地址格式。

| 主存字块标记（7位）  | Cache字块地址（9位） | 字块内地址（4位） |
| -------------------- | -------------------- | ----------------- |
| 主存字块标记（9位）  | 组地址（7位）        | 字块内地址（4位） |
| 主存字块标记（16位） | 字块内地址（4位）    |                   |

## 3

假设主存容量为512KB，Cache容量为4KB，每个字块为16个字，每个字32位。 

（1）Cache地址有多少位？可容纳多少块？ 

一块大小：16*32/8=64B 

2^12/64=2 \^6=64 块

（2）主存地址有多少位？可容纳多少块？ 

512KB/64B=8192 块

（3）在直接映射方式下，主存的第几块映射到Cache中的第5块（设起始字块为第1块）？ 

由于Cache共有64块，主存共有8192块，因此主存的第 5，64+5，2×64+5，…，213-64+5块都能映射到Cache的第5块中。 

（4）画出直接映射方式下主存地址字段中各段的位数。 

7 7 6



## 4

假设主存容量为512K×16位，Cache容量为4096×16位，块长为4个16位的字，访 

存地址为字地址。 

（1）在直接映射方式下，设计主存的地址格式。 

7 10 2

（2）全相联映射方式下，设计主存的地址格式。 

17 2

（3）在二路组相联映射方式下，设计主存的地址格式。 

8 9 2

（4）若主存容量为512K×32位，块长不变，在四路组相联映射方式下，设计主存的地址格式。

10 8 2

## 5

设某主机主存容量为16MB，Cache容量为8KB。每字块有8个字，每字为32位。设 

计一个四路组相联映射的Cache组织。 

（1）画出主存地址字段中各段的位数。 

（2）设Cache初态为空，CPU依次从主存第0,1,2, … ,99号单元读出100个字（主存一次 

读出一个字），并重复此次序读10次，问命中率是多少？ 

（3） 若Cache的速度是主存速度的5倍，试问有Cache和无Cache相比，速度提高多少倍？ 

（4）系统的效率多少？

# 指令信息

1. 找到地址总位数，
2. 减去2倍地址码
3. 剩下的数n，2^n就是地址数
4. 用这个2^n减去二地址剩下的，得到m
5. m*2^地址码



## 1

32位单地址，地址码12位，有250条二地址，单地址有多少？

32-2*12 = 8

2^8 = 256

256 - 250 =6

6*2^12=24KB



## 2

5.2. 设指令字长为16位，采用扩展操作码技术，每个操作数的地址为6位，如果定义了13条二地址指令，试问还可以安排多少条一地址指令？ 

解：二地址指令格式如下：

![img](img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/wpsF5D8.tmp.jpg) 

4位操作码共有16种编码，其中13种用来定义二地址指令，还剩3种可用作扩展标志。一地址指令条数 =3×2^6 =192条



16-6*2 = 4

2^4=16

16-13=3

3*2^6=192



## 3



指令字长12，地址字段4，12条二操作数，问单操作数数量

12-4*2 = 4

2^4-12=4

4*2^4=64





## 4



![image-20220302235908370](img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220302235908370.png)

16-4*3=4

2^4=16

也就是说有16条指令，其中三地址占了14



## 5

某指令系统字长为16位，地址码为4位，试提出一种方案，使该指令系统有8条三地址指令、16条二地址指令、100条一地址指令。

![img](img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/wps24A4.tmp.jpg)

![img](img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/wps8C0A.tmp.jpg)



分配之后的地址，OP+1，然后算下一条

# 中断

## 1

7.4. 设某机有5个中断源L0、L1、L2、L3、L4，按中断响应的优先次序由高到低排序为L0→L1→L2→L3→L4，现要求中断处理次序改为L1→L4→L2→L0→L3，根据下面的格式，写出各中断源的屏蔽字。

  解：各中断源屏蔽状态见下表：

| 中断源 | 屏蔽字 |      |      |      |      |
| ------ | ------ | ---- | ---- | ---- | ---- |
| 0      | 1      | 2    | 3    | 4    |      |
| L0     | 1      | 0    | 0    | 1    | 0    |
| L1     | 1      | 1    | 1    | 1    | 1    |
| L2     | 1      | 0    | 1    | 1    | 0    |
| L3     | 0      | 0    | 0    | 1    | 0    |
| L4     | 1      | 0    | 1    | 1    | 1    |

表中：设屏蔽位=1，表示屏蔽；屏蔽位=0，表示中断开放。

## 2

 设某机有3个中断源，其优先级按1→2→3降序排列。假设中断处理时间均为τ，在下图所示的时间内共发生5次中断请求，图中①表示1级中断源发出中断请求信号，其余类推，画出CPU执行程序的轨迹。（一定要体现出来先回到主程序）

![img](img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/wps9D3F.tmp.jpg)

## 3

某机有4个中断源1、2、3、4，其响应优先级按1→2→3→4降序排列，现要求将中断处理次序改为4→1→3→2。根据下图给出的4个中断源的请求时刻，画出CPU执行程序的轨迹。设每个中断源的中断服务程序时间均为20µs。

![img](img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/wpsF9C7.tmp.jpg)

# 指令信息流程图

画出执行“ADD  \*-5”指令（*为相对寻址特征）的信息流程图。设另一个操作数和结果存于ACC中，并假设（PC）=4000H。

省略的取指令的过程包括了

PC→MAR

M→MDR

MDR→IR



EA计算地址偏移，然后取MAR里面找地址，再按照地址去MDR里面取数据

取到以后把数据和另一个操作数ACC加起来

星号*不用管



![img](img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/wpsC29D.tmp.jpg)

# ADD指令

一相对寻址的转移指令占3个字节，第一个字节是操作码，第二、三字节是相对位移量，而数据在存储器中以高字节地址为字地址的存储方式。假设当前PC值是4000H。试问当结果为0，执行JZ *+35和JZ *-17指令时，该指令第二、三字节的机器代码各为多少？

当执行JZ指令时，指令第二三字节的内容不变，PC的内容变为4003H。

此时转移指令第二三字节内容各为：

A1= +35 = 100011 = 23H

A2= -17 = -10001=11101111 = EFH

其有效地址各为：

EA1= (PC) +35 = 4003H+0023H= 4026H

EA2= (PC)–17 = 4003H+FFEFH= 3FF2H



