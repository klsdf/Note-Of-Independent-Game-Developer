

# 循环冗余校验码

要发送的数据为101110，采用CRC的生成多项式是P(X)=X^3+1。试求其余数。

1. 确定其多项式二进制 1001，以及最高次幂3

2. 给发送数据后面加上3个0

3. 进行模2除法，余数为011，位数和最高次幂一样高

   

# 奈氏准则和香农公式

奈氏准则：$$极限码元传输速率= 2W Baud= 2 \times 3000= 6000 Baud$$

香农定理：$$信道极限传输速率=Wlog_2(1+\frac{S}{N})$$

W是信道的带宽，S/N是信噪比

## 1

某信道最高码元速率为2000码元/秒，现在码元振幅有16种，那么最高数据率是多少？

解：已知了最高码元速率，只需要再乘以$log_216$即可。

$最大速率=2000*log_216=8000$

## 2

若某通信链路的带宽为3kHz，使用的是10进制码元(10种电信号)，则该通信链路的最大数据传输率是多少?

解：$最大速率= 2 * 3000 *\lceil log_210\rceil = 24000bit/s$

## 3

用香农公式计算，假定带宽3100Hz，信息最大传输速率为35kbits，如果想要最大信息传输速率提高60%，S/N应该提高多少？

若再提高10倍信噪比，能否让传输速率再+20%

![img](file:///C:\Users\闫辰祥\AppData\Local\Temp\ksohtml\wpsC41F.tmp.jpg)

![img](file:///C:\Users\闫辰祥\AppData\Local\Temp\ksohtml\wpsC420.tmp.jpg) 

求得：S/N = 2503.4880
		S2/N2 = 274128.8678

求得 (S2/N2)/(S/N)=109.5

![img](file:///C:\Users\闫辰祥\AppData\Local\Temp\ksohtml\wpsC421.tmp.jpg) 

66729/(1.6*35000)=1.191

不足20%

# 码分多址（CDMA通信）

例题：

共有四个站进行码分多址CDMA通信，四个站的码片序列为：

A：（-1 -1 -1 +1 +1 -1 +1 +1）      B：（ -1 -1 +1 -1 +1 +1 +1 -1）

C：（-1 +1 -1 +1 +1 +1 -1 -1）      D：（-1 +1 -1 -1 -1 -1 +1 -1）

现在收到的序列为（-1 +1 -3 +1 -1 -3 +1 +1），问哪个站发送了数据，发送的是1还是0？

解：对4个选项分别求内积。所谓的内积，就是每一项都进行二进制乘法，乘完之后，加起来。之后除以8，就行了。

A的内积：（-1 -1 -1 +1 +1 -1 +1 +1）*（-1 +1 -3 +1 -1 -3 +1 +1）/ 8 = (+1 -1 +3 +1  -1 +3 +1 +1)  / 8 = 1

B的内积：（ -1 -1 +1 -1 +1 +1 +1 -1）*（-1 +1 -3 +1 -1 -3 +1 +1）/ 8 =（+1 -1  -3  -1 -1 -3 +1 -1 ）/8 = -1

C的内积：0

D的内积：1

**所以A和D发送了1，B发送了0，C没有发送。**



# PPP帧的填充（7D 5E    7D 5D）

一个ppp帧的数据部分（用十六进制写出）是7D 5E FE 27 7D 5D 7D 5D 65 7D 5E。其真实数据是什么？

PPP帧在填充的时候，会将7E→7D 5E   讲7D→7D 5D

所以在还原的时候，遇到7D 5E就将其还原成7E就行了。7D也一样。

真正的16进制数据是7E FE 27 7D 7D 65 7E

# 以太网的自学习

通过交换机实现



![](img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211222154924505.png)





| 动作     | 交换表状态 | 向哪些接口准发帧 | 说明               |
| -------- | ---------- | ---------------- | ------------------ |
| A发送给D | 写入(A,1)  | 广播             | 广播并记录A        |
| D发送给A | 写入(D,4)  | 1                | 记录D，并直接发给A |
| E发送给A | 写入(E,5)  | 1                | 记录E，并直接发A   |
| A发送给E | 更新(A,1)  | 5                | 直接发给E          |











| 动作     | 交换表状态   | 向哪些接口准发帧  | 说明                       |
| -------- | ------------ | ----------------- | -------------------------- |
| A发送给D | 无           | 除A以外，进行广播 | D接收了帧，同时记录A的端口 |
| D发送给A | (A,1)        | 1                 | A已经被记录，可以直接送到  |
| E发送给A | (A,1)，(E,5) | 1                 | 记录E的端口                |
| A发送给E | (A,1)，(E,5) | 5                 | 直接发送给E                |





# 路由表更新

B的路由器信息如下

| 目的网络 | 距离 | 下一跳路由器 |
| -------- | ---- | ------------ |
| N1       | 7    | A            |
| N2       | 2    | C            |
| N6       | 8    | F            |
| N8       | 4    | E            |
| N9       | 4    | F            |

现在B收到了来自C路由器的信息

| 目的网络 | 距离 |
| -------- | ---- |
| N2       | 4    |
| N3       | 8    |
| N6       | 4    |
| N8       | 3    |
| N9       | 5    |

求B更新后的信息



| 目的网络 | 距离 |
| -------- | ---- |
| N2       | 5    |
| N3       | 9    |
| N6       | 5    |
| N8       | 4    |
| N9       | 6    |



首先第一步，把接收到的数据全部+1，这是因为从C路由器到B也是一个距离



| 目的网络 | 距离 | 下一跳 | 说明                   |
| -------- | ---- | ------ | ---------------------- |
| N1       | 7    | A      | 没有更新信息           |
| N2       | 5    | C      | 更新距离               |
| N3       | 9    | C      | 发现新的网络，并记录   |
| N6       | 5    | C      | 发现距离更短的路径     |
| N8       | 4    | E      | 距离一样，不更新       |
| N9       | 4    | F      | 之前的距离更小，不更新 |
|          |      |        |                        |

# 路由表下一跳

这个玩意的计算方法就是用收到的分组分别与子网掩码进行与运算，如果算完发现能和目的网络对上，那么下一跳就选谁





设某路由器建立了如表所示路由表。

| 目的网络      | 子网掩码        | 下一跳   |
| ------------- | --------------- | -------- |
| 128.96.40.0   | 255.255.255.128 | 接口Eth0 |
| 128.96.40.128 | 255.255.255.128 | 接口Eth1 |
| 128.96.41.0   | 255.255.255.128 | R2       |
| 192.4.123.0   | 255.255.255.192 | R3       |
| *(默认)       |                 | R4       |

现在收到了5个分组，其目的地址为，分别计算下一跳

(1) 128.96.40. 10

128.96.40.10与  255.255.255.128

发现答案是128.96.40.0，所以下一跳为接口Eth0



(2) 128.96.41. 12   R2    

(3) 128. 96. 41. 151   R4

(4) 192.4.123. 17 R3

(5) 192.4.123.90   R4



# 路由器选择

收到一个分组。其目的地址 **D = 11.1.2.5**。要查找的路由表中有这样三项： 

  路由 **1** 到达网络 **11.0.0.0/8**  

  路由 **2** 到达网络 **11.1.0.0/16**  

  路由 **3** 到达网络 **11.1.2.0/24**  

  试问在转发这个分组时应当选择哪一个路由？



路由三，同网段内，掩码长度最长

# 数据报分片

TCP首部20字节，UDP8字节，DF是否不允许分片   MF：是否还有更多分片

MTU：最大传输单元，包括了首部和数据部分



已知一个分组的数据部分长度为3800字节，网络规定分组的分片长度不能超过1420字节，假设IP分组的首部采用固定首部20个字节。请问原始分组需要分成几个分片?每个分片的总长度、标识字段(注:原始分组标识字段是666)、DF 标志位(注: 0表示可分片，1表示不可分片)、MF标志位(注: 0表示是最后分片，1表示后面还有分片)、分片偏移字段各是多少?





















首先分析题目

1. 首部20字节，说明是TCP
2. 分片不能超过1420字节，这个分片包括了数据和首部，而首部20字节，说明数据1400字节
3. 一共3800字节，每个1400字节，除一下，发现需要三个分片

















|          | 总长度 | 标识字段 | DF标志位 | MF标志位 | 分片偏移地址 |
| -------- | ------ | -------- | -------- | -------- | ------------ |
| 原始分组 | 3820   | 666      | 0        | 0        | 0            |
| 1分组    | 1420   | 666      | 0        | 1        | 0            |
| 2分组    | 1420   | 666      | 0        | 1        | 1400/8=175   |
| 3分组    | 1020   | 666      | 0        | 0        | 2800/8=350   |

总长度：别忘了加首部的20字节

标识字段：所有人统一

DF：因为需要分片所以允许分片

MF：前几个分片之后还有更多分片，最后一个没有

偏移地址：从0开始，每次加片长/8





# 超网聚合

1.有如下的四个/24地址块，试进行最大可能的聚合。
212.56.132.0/24
212 56.133.0/24
212.56.134.0/24
212.56.135.0/24



212.56.132.0/24的第三个字节的二进制表示是**100001**00:

212.56.133.0/24的第三个字节的二进制表示是**100001**01;

212.56.134.0/24的第三个字节的二进制表示是**100001**10; 

212.56.135.0/24的第三个字节的二进制表示是**100001**11。

可以看出，第三个字节仅最后2位不一样，而前面6位都是相同的(用粗体字加下画线来表示)。这4个地址块的共同前缀是22位: 11010100 0110000000100

215.56.132.0/22

# 子网划分

现有一个C类网段193. 160. 80.0， 要将其划分为6个子网，请问如何指定子网掩码?每个子网的网络地址、广播地址分别是多少?可分配的主机地址范围是多少?

2的三次方是8，所以划分三位数据位到主机位

掩码是3*8+3 = 27



第一个子网的网络号为255.255.255.001，不能从全0开始。

以此类推





某单位分配到一个地址块129.250/16。该单位有4000台计算机，平均分布在16个不同的地点。试给每一个地点分配个地址块， 并算出每个地址块中IP地址的最小值和最大值。

解答: 4000台计算机平均分布在16个不同的地点，每个地点有250台计算机。因此，主机号有8位就够了。这样，网络前缀可以选用24位。16 个不同地点需要有16个地址块。每个地点分到一个/24地址块就够用了。结果如下:

129.250.1/24，IP 地址范围: 129.250.1.0~ 129.250. 1.255

129.250.2/24, IP 地址范围: 129.250.2.0 ~ 129.250.2.255

129.250.16/24，IP 地址范围: 129.250.16.0 ~ 129.250.16.255

# 网桥转发表

1.如图表示有五个站分别连接在三个局域网上，并且用网桥1和网桥2连接起来。每一个网桥
都有两个接口(1和2)。在一开始，两个网桥中的转发表都是空的。以后有以下各站向其他的
站按先后顺序发送了数据帧: A发送给E，C发送给B，D发送给C，B发送给A，D发送给A，试把
有关数据填写在表中。

![image-20220304225949335](img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220304225949335.png)

| 发送的帧 | 网桥1转发表 | 网桥2转发表 | 网桥1的处理 | 网桥2的处理 |
| -------- | ----------- | ----------- | ----------- | ----------- |
| A→E      | （A，1）    | （A，1）    | 转发，写入  | 转发，写入  |
| C→B      | （C，2）    | （C，1）    | 转发，写入  | 转发，写入  |
| D→C      | （D，2）    | （D，2）    | 写入，抛弃  | 写入，转发  |
| B→A      | （B，1）    |             | 写入，抛弃  |             |
| D→A      |             |             | 转发        | 转发        |

转发表第一个是主机，第二个是接口

（A，1）代表是从接口1接收到了A的数据



网桥有三种操作 转发、写入、丢弃

# CSMA/CD最短帧长

假定lkm长的CSMA/CD网络的数据率为1Gb/s.设信号在网络上的传播速率为200 000km/s求能够使用此协议的最短帧长。

1. 计算信号往返时间：用往返的路程2km除以速度2*10^5，
2. 计算发送的数据量：上式结果乘以数据率1*10^9

答案为10^4bit



# TCP拥塞控制

包括慢启动，快恢复

- 初始化阈值为16，快开始，指数增加
- 到了阈值之后，每次加1
- 如果拥堵，那么降为拥塞值的一般，并重新快开始
- 如果遇到3个atk，那么也是降一半，但是每次只+1

# ipv6的零压缩

ipv6包含8个16位。一般用16进制来表示



1. 丢弃前面的0
2. 如果有连续两个都是全0，那么直接用两个冒号来表示 ，**一个地址只能用一次！！！**
3. 如果之前已经用了二号法则，而还有很多0，那么单独的0000 压缩为一个0

压缩 2001:0000:3238:DFE1:0063:0000:0000:FEFB

 丢弃前面的0   2001：0000：3238：DFE1：63：0000：0000：FEFB

丢弃连续0  2001：0000：3238：DFE1：63：：FEFB

2001：0：3238：DFE1：63：：FEFB









**（1）0000:0000:0F53:6382:AB00:67DB:BB27:7332** 

：：F53：6382：AB00 : 67DB : BB27 :7332

  **（2）0000:0000:0000:0000:0000:0000:004D:ABCD** 

：：4D：ABCD

  **（3）0000:0000:0000：AF36:7328:0000:87AA:0398** 

：：AF36：7328：0：87AA：398

  **（4）2819:00AF:0000:0000:0000:0035:0CB2:B271**

2819：AF：：35：CB2：B271



 

# CIDR地址

已知一cidr地址块为200.56.168.0/21

(1)用二进制表示这个地址块（2）这个cidr包含多少c类地址块？



（1）200.56.168.0/21=1100100000111000 10101000 00000000

（2）C类地址有24位，所以有三位地址可以分出来

​	2^（24-21）=8



# 网络时延

假定网络的利用率达到了90%。 试估算一下 现在的网络时延是它的最小值的多少倍?

1(1-0.9)=10

# 时延

收发两端之间的传输距离为1000 km,信号在媒体上的传播速率为2 x 10^8m/s,，计算以下两种情况的发送时延和传播时延:

（1）数据长度为10^7 bit,数据发送速率为100 kbit/s


​	发送时延为10^7 bit/(100 kbit/s)= 100 s,
​	传播时延为10\^6m/(2x10^8 m/s)= 5 ms。
​	发送时延远大于传播时延。

（2）数据长度为10^3 bit,数据发送速率为1 Gbit/s.

发送时延为10^3 bit/(1 Gbit/s)= 1 us,

传播时延为5 ms。

发送时延远小于传播时延。

# 绘制连接拓扑结构

<img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220310001032721.png" alt="image-20220310001032721" style="zoom:33%;" />



<img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220310001052624.png" alt="image-20220310001052624" style="zoom:33%;" />

# 地址匹配

![image-20220310001205370](img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220310001205370.png)

# 地址数量

![image-20220310001520056](img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220310001520056.png)

# RTT和RTO计算

**假定TCP在开始建立连接时，发送方设定超时重传时间是RTO=6s。**

RTO=RTTs+4*RTTd

**(1)当发送方接到对方的连接确认报文段时，测量出RTT样本值为1.5s。试计算现在的RTO值。**

![image-20220310101018294](img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220310101018294.png)

**(2)当发送方发送数据报文段并接收到确认时，测量出RTT样本值为2.5s。试计算现在的RTO值。**







