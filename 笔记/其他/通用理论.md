# 进制转换

## 常用二进制

- $2^8 = 255$
- $2^{16} = 65535$

# 逻辑代数

## 运算

### 与

- 代码符号：`&`。

- 逻辑函数：$Y=A\cdot B$

- 真值表

| A    | B    | Y    |
| ---- | ---- | ---- |
| 0    | 0    | 0    |
| 0    | 1    | 0    |
| 1    | 0    | 0    |
| 1    | 1    | 1    |

### 或

- 代码符号：`|`。
- 逻辑函数：$Y = A+B$

- 真值表

| A    | B    | Y    |
| ---- | ---- | ---- |
| 0    | 0    | 0    |
| 0    | 1    | 1    |
| 1    | 0    | 1    |
| 1    | 1    | 1    |



### 非

- 代码符号：`!`
- 逻辑函数：$Y = \overline{A} $

| A    | Y    |
| ---- | ---- |
| 0    | 1    |
| 1    | 0    |

### 异或







# 编码

## BCD码

BCD码用4位二进制数来表示一位十进制数，可以建立一个一一映射。

BCD（Binary Coded Decimal），意思是用2进制编码10进制。

十进制数有10个数码，用2进制来表示的话，最少用4位2进制，也就是$2^4=16$来表示。这样的话，4位2进制实际上能表示16种数码，用于10进制的话其实有点浪费了，所以我们可以手动更改二进制的位权，合理编码10进制。

常见的BCD码有8421码，5421码呵2421码。意思就是说位权从高到低分别位8421，5421和2421。



例：

（1001 0011.0010 0110）~8421BCD~=（93.26）~10~



### 8421码

所谓8421,就是因为规定二进制数1111的每位的权值分别为8421

8421码的映射关系如下

|     0     |     1     |     2     |     3     |  4   |  5   |  6   |  7   |  8   |  9   |
| :-------: | :-------: | :-------: | :-------: | :--: | :--: | :--: | :--: | :--: | :--: |
|   0000    |   0001    |   0010    |   0011    | 0100 | 0101 | 0110 | 0111 | 1000 | 1001 |
|    10     |    11     |    12     |    13     |      |      |      |      |      |      |
| 0001 0000 | 0001 0001 | 0001 0010 | 0001 0011 |      |      |      |      |      |      |

这个东西光靠讲讲不清的,但是举一个例子就很简单了

5+8=13,这个是十进制的表示,接下来我用8421码来表示

0101+1000=1101,此时发现13不在映射表内,我们知道13应该表示为(0001 0011),为了使这个10能进位,我们可以手动加一个6,因为4位二进制最大值就是15,原理就是原数+6后取16的模作为低位,高位进位,且保留高位.

所以可以确保加了之后高位进位.之后1101+0110=0001 0011,这样就可以用8421码表示十进制了.

### 余3码

就是在8421码的基础上再加3.

|  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 0011 | 0100 | 0101 | 0110 | 0111 | 1000 | 1001 | 1010 | 1011 | 1100 |

### 2421码

人为规定二进制1111的权值分别为2421,因为有两个2,所以为了防止编码,规定0~4开头必须是0,后面开头必须是1

|  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 0000 | 0001 | 0010 | 0011 | 0100 | 1011 | 1100 | 1101 | 1110 | 1111 |





# 数据储存

## 问题的提出

在计算机导论里面我们都学过,计算机最早都是10进制的,而且里面集成了很多加减乘除的电路,这就导致计算机的电路结构异常复杂,而且体积庞大,这时候人们就有了疑问.在运算中,设计加法电路比减法电路简单的多,而且体积还小,那要是能把减法也能转换成加法就好了.

然后人们就想到了使用反码和补码来解决加减法准换的问题. 

## 原码,反码,补码和移码

### 原码

在计算机存储中,正数很好表示,直接转换成二进制就可以了,但是负数就很让人头大了,科学家们规定,一个数字开头那一位为符号位,后面的称为数值位.这样简单朴素易懂的方法所表示的数称为**原码**

<table>
<thead>
  <tr>
    <th>原数据</th>
    <th>符号位</th>
    <th colspan="3">数值位</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>6</td>
    <td>0</td>
    <td>1</td>
    <td>1</td>
    <td>0</td>
  </tr>
</tbody>
</table>

<table>
<thead>
  <tr>
    <th>原数据</th>
    <th>符号位</th>
    <th colspan="3">数值位</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>-6</td>
    <td>1</td>
    <td>1</td>
    <td>1</td>
    <td>0</td>
  </tr>
</tbody>
</table>

### 反码

- 如果原数据是正数(符号位为0),那么反码等于原码
- 如果原数据是负数(符号位为1),那么**原码数值位取反**后就是反码

<table>
<thead>
  <tr>
    <th>原数据</th>
    <th>符号位</th>
    <th colspan="3">数值位</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>6</td>
    <td>0</td>
    <td>1</td>
    <td>1</td>
    <td>0</td>
  </tr>
</tbody>
</table>

<table>
<thead>
  <tr>
    <th>原数据</th>
    <th>符号位</th>
    <th colspan="3">数值位</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>6</td>
    <td>1</td>
    <td>0</td>
    <td>0</td>
    <td>1</td>
  </tr>
</tbody>
</table>

这时候就诞生了一个问题,那就是0在反码中居然有两种表示法,分别是+0和-0.

<table>
<thead>
  <tr>
    <th>原数据</th>
    <th>符号位</th>
    <th colspan="3">数值位</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>+0</td>
    <td>0</td>
    <td>0</td>
    <td>0</td>
    <td>0</td>
  </tr>
</tbody>
</table>

<table>
<thead>
  <tr>
    <th>原数据</th>
    <th>符号位</th>
    <th colspan="3">数值位</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>-0</td>
    <td>1</td>
    <td>1</td>
    <td>1</td>
    <td>1</td>
  </tr>
</tbody>
</table>

实际上反码只是原码到补码的中间状态,实际中并没有什么卵用.

### 补码

- 正数的补码=原码=反码
- 负数补码=负数反码+1

<table>
<thead>
  <tr>
    <th>原数据</th>
    <th>符号位</th>
    <th colspan="3">数值位</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>6</td>
    <td>0</td>
    <td>1</td>
    <td>1</td>
    <td>0</td>
  </tr>
</tbody>
</table>

<table>
<thead>
  <tr>
    <th>原数据</th>
    <th>符号位</th>
    <th colspan="3">数值位</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>6</td>
    <td>1</td>
    <td>0</td>
    <td>1</td>
    <td>0</td>
  </tr>
</tbody>
</table>

而且在补码中,解决了+0和-0的问题.

### 移码

移码是在补码的基础上把符号位取反.假如把移码看成无符号数,那么移码的单调性和真值保持一致,可以很方便判断大小.

**注意:移码只能用于表示整数.**



<img src="img/image-20200909140531424.png" alt="image-20200909140531424" style="zoom:50%;" />

<img src="img/image-20200909140247503.png" alt="image-20200909140247503" style="zoom: 67%;" />

### 小技巧

由$[x_补]$快速求$[-x_补]$的方法:

符号位,数值位全部取反,之后末尾+1

## 补码详解

### 原码的减法运算

3-1=2,这个式子大家都觉得很简单,但是正如我刚才所说的,计算机里面没有减法电路,那么应该怎样才能用加法来替换减法呢?这个很容易想到, $3-1=2\Rightarrow  3+(-1)=2 $.也就是说只要把减法运算转化为加其加法逆元就可以了.但是真的就这么简单吗?我们不妨试一下.

$011 - 001 = 011 + 101 = 1000$

结果是8,并没有得到我们想要的2,这是为什么呢?因为我们101中,开头那个1是符号位表示负数,但是我们在运算的时候却把它当成数值位去计算的,所以导致计算结果过大.

### 补码的提出

如上文所说,符号位应该怎末处理,成了首要之急.这时候就有大佬想到了解决思路,既然符号位会让数值变大,那假如让它大的恰到好处呢?比如说我原来的数是5,如果我加了这个符号位之后是9,那么我如果同时对这两个数取模4操作,那么$ 5\%4= 9\%4=1$

补码运算的思想就是让原来的数加完后,大到一定程度,之后取模,舍掉高位,剩下的就是正确答案. 

那么接下来就好办了, $(3-1) \mod 16 =  (3-1+16)\mod16$.注意咯!这个-1+16实际上就是-1的补码了.我们可以试一下看看

$10000-00001=01111$.

$(1001)_补=1111$

注意,我这两个用的位数不一样,补码是4位,而16-1是5位,这个后面会继续说到,这里只需要明白补码的原理就是给负数+一个数,之后取模保证和原来的数相等.

### 补码运算原理

我们刚才明白了补码的本质,那么接下来就来看看它究竟是如何运算的.

$(3-1) \mod 16 $

$= (3 \mod 16 + (-1)\mod 16 )\mod16$    //模运算分配律

$=(3 + (16-1) \mod 16)\mod 16$

现在问题又来了,我们虽然知道16-1就是-1的补码了,但是还是里面有一个减法啊,这又该怎么办????

**接下来就是全文的灵魂部分了:**

$-1\mod 16=(-1+16)\%16=(-1+8+8)\%16=(-1+8+7+1)\%16$

现在式子中就有了一个特殊的减法:7-1.**因为7的二进制数全1,和7做减法运算,就相当于进行数值位取反的运算.**

举几个例子$7-1=111-001=110$,   $7-6=111-110=001$

我们只看数值位,先不管前面的符号位,待会会说.看,这样111和任何数相减是不是就等于进行数值位取反操作了.

此时式子可以写成:

$-1\mod 16=(8+1+数值位取反)\%16$

**前面那个8我想已经很容易看出来是啥了,其实就是符号位.**用二进制写就是

$-1\ mod 16$

$=1000+1+(001)_{取反}$

$=1000+110+1$

$=1110+1$

= 反码+1

= 补码

看吧,此时-1的反码就有符号位了.这个符号位不是本身自带的,而是通过模运算得到的.

所以综上所述,负数的补码=符号位1+数值位取反+1

如果规定原码自带数值位,即$-1=1001$,那么

- 反码=符号位不变,数值位取反

- 补码=反码+1.

### 完整计算过程

$$
\begin{equation*}
\begin{split}
(3-1)\mod 16&=(3+(-1))\mod 16\\
    &=(3\mod 16 + (-1)\mod 16)\mod 16\\
    &=(3+(-1)\mod 16)\mod 16\\
    &=(3+(16-1)\mod 16)\mod 16\\
    &=(3+(8+7+1-1)\mod16)\mod 16\\
    &=(011+(1000+111-001+001)\mod 16)\mod 16\\
    &=(011+(1110+001)\mod 16)\mod 16\\
    &=(011+1111)\mod 16\\
    &=0001,0010\mod16\\
    &=0010\\
    &=2
\end{split}
\end{equation*}
$$

总结一下:

- 补码的原理就是加一个数取模之后数值不变
- 补码加的这个数刚好可以拆成一个符号位,还有一个全1的特殊数值最后加1
- 这个全1的数值和原来的数做减法等价于按位取反
- 把符号位和取反得到的数叫做反码
- 反码最后加1得到补码
- 负数通过补码可以变成正数,这个数会变大
- 正数和负数加完整体都会变大,但是最后一取模,原来的数值不会变化.
- 这个取模的运算在计算机里面就是高位溢出比如(0001 0010)高位溢出变为(0010)
- 这个数值占n位,就模$2^n$,比如上例中2占4位,就模16

## 移位运算

### 算数移位

左移相当于乘2,右移相当于除2.

一般的正数,直接填0就行了,但是对于反码和补码要注意一下,反码刚好和原码相反,所以要填1,保证转换过去之后和原码一样.补码就更特殊了,因为最后加了一个1,导致最后几位再次取反,这样子一旦算数左移,后边空出来的位就跟原码一样补0,但是算术右移,前面空出来的跟反码一样补1.

![image-20200911151641756](image-20200911151641756.png)

### 逻辑移位

这个移位不论什么数,怎末移,都补0,非常简单

### 循环移位

顾名思义,把高位溢出的数据,补到低位去.

## 定点数的储存

1. 无符号数:整个机器字长的全部二进制位均为数值位，没有符号位，相当于数的绝对值.没有啥说的,这个数的二进制是几,机器就存几
2. 有符号数:开头第一位是符号位,之后用原码反码补码来表示负数.

# 搜索技巧

```pseudocode
"完全匹配"  
intitle:xx /*标题必须包含xx*/
三国演义 filetype:doc /*搜索类型必须为doc*/
```

