# 第一章 绪论

## 数字图像处理的基本图像类型

- 二值图像

- 灰度图像

- 索引图像

- RGB图像

  

# 第二章 数字图像处理基础

## 人眼两种光敏细胞

- 锥状细胞---白昼视觉

  识别图像细节，分辨光的强弱、彩色

  

- 杆状细胞---夜视觉

  感知景物形象，不能感觉彩色，对低照度景物敏感

##  视觉适应性

- 暗适应
  当我们从明亮的阳光下走入正在放映电影的影院时，会感到一片漆黑，但过一会儿后，视觉便会逐渐恢复。人眼这种适应暗环境的能力称为暗适应性，通常这个适应过程约需30 s。因为完成视觉过程的视敏细胞发生了变换，由杆状细胞代替锥状细胞工作。
- 亮适应
  和暗适应性相比，亮适应性过程要快得多，通常只需几秒钟。例如，当在黑暗中突然打开电灯时，人的视觉几乎马上就可以恢复。这是因为锥状细胞恢复工作所需的时间要比杆状细胞少得多。

## RGB转HSV

有一像素的颜色为（100,150,200）,求其对应的H、S、I值

![image-20220309204322107](img/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/image-20220309204322107.png)

## 图像数据量

![image-20220309205507095](img/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/image-20220309205507095.png)

1024×768像素的16位图像数据量为____(MB)

1024*768\*16/8



## 量化

对缓变的图像， 应该细量化， 粗采样， 以避免假轮廓。

对细节丰富的图像， 应细采样， 粗量化， 以避免模糊（混叠）。

# 第四章 图像增强

由于目前没有衡量图像增强质量通用的、客观的标准，增强的方法往往具有针对性，增强的结果只是靠人的主观感觉加以评价。

##  灰度变换

 把原图像的像素灰度经过某个变换函数变换成新的图像灰度。灰度变换的目的是为了改善画质，使图像的显示效果更加清晰



$$
g(x, y)=\frac{d-c}{b-a}[f(x, y)-a]+c
$$

## 直方图均衡化

设一个图像大小为64*64，有8个灰度级。现在对其均衡化。



| 原图像灰度级 | 出现概论 | 分布函数 | sk            | 转化到 | 答案                |
| ------------ | -------- | -------- | ------------- | ------ | ------------------- |
| 0            | 0.19     | 0.19     | 7*0.19 = 1.33 | 1      |                     |
| 1            | 0.25     | 0.44     | 7*0.44=3.08   | 3      | 0.19                |
| 2            | 0.21     | 0.65     | 4.55          | 5      |                     |
| 3            | 0.16     | 0.81     | 5.67          | 6      | 0.25                |
| 4            | 0.08     | 0.89     | 6.23          | 6      |                     |
| 5            | 0.06     | 0.95     | 6.65          | 7      | 0.21                |
| 6            | 0.03     | 0.98     | 6.68          | 7      | 0.16+0.08=0.24      |
| 7            | 0.02     | 1        | 7             | 7      | 0.06+0.03+0.02=0.11 |

- 出现概率

  就是原图像中这个灰度的比率，计算方法就是把点的数量除以总像素的数量。

- 分布函数

  就是把各个灰度的出现概率加起来就行了

- $s_k = int[(L-1)+0.5]$

  本题中，L=7，也就是int（6.5）==7

 

## 图像平滑

- Box模板

  所谓Box模板是指模板中所有系数都取相同值的模板

  <img src="img/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/image-20220309213048540.png" alt="image-20220309213048540" style="zoom:33%;" />

- 中值滤波

  

- Gaussian模板

  <img src="img/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/image-20220309213007572.png" alt="image-20220309213007572" style="zoom:33%;" />

## 图像锐化



- Robert算子

  对噪声敏感；模板尺寸为2*2，中心位置不好确定

  $\left(\begin{array}{ccc}-1 & 0 \\ 0 & 1\end{array}\right)$ $\left(\begin{array}{ccc}0 & -1 \\ 1 & 0\end{array}\right)$

- Prewwit算子

  引入了平均因素，能够抑制噪声，操作简单

  $\left(\begin{array}{ccc}-1 & 0 & 1\\ -1 & 0 & 1 \\ -1 & 0 &1\end{array}\right)$$\left(\begin{array}{ccc}-1 & -1 &-1 \\ 0 & 0 & 0 \\ 1&1&1\end{array}\right)$

- Sobel算子

  引入了平均因素，抑制噪声优于prewwit算子，把重点放在接近于模板中心的像素点。

  $\left(\begin{array}{ccc}-1 & 0 & 1\\ -2 & 0 & 2 \\ -1 & 0 &1\end{array}\right)$$\left(\begin{array}{ccc}-1 & -2 & -1\\ 0 & 0 & 0 \\ -1 & -2 & -1\end{array}\right)$

- 拉普拉斯算子

  拉普拉斯算子也增强了图像的噪声， 但与梯度法相比， 拉普拉斯算子对噪声的作用较梯度法弱。故用拉普拉斯算子进行边缘检测时，有必要先对图像进行平滑处理。

  $\left(\begin{array}{ccc}0 & -1 &0 \\ -1 & 4* & -1 \\ 0 & -1 & 0\end{array}\right)$

## 图像平滑（去噪）

- 邻域平均法

  会造成图像一定程度上的模糊

  所谓Box模板是指模板中所有系数都取相同值的模板
  $$
  \frac{1}{9}\left[\begin{array}{ccc}
  1 & 1 & 1 \\
  1 & 1^{*} & 1 \\
  1 & 1 & 1
  \end{array}\right]
  $$
  
- 中值滤波法

  把一堆数从小到大排列，取中间值

  

  **算术平均平滑对含有高斯噪声的图像有效； 
  中值滤波对含有椒盐噪声图像的去噪声效果较好。**



### 一阶微分 vs二阶微分

一阶微分一般产生更粗的边缘；

二阶微分则产生更细的边缘；

相对一阶微分而言，二阶微分对细孤立点等小细节有更强的响应。

## 代数运算

- 加运算

  ![image-20220309213943277](img/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/image-20220309213943277.png)
  
- 减运算
  
  
  
  

# 第五章 图像分割

## 单一区域生长法

![image-20220301211631881](img/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/image-20220301211631881.png)

T = 3 ； T=2；T=6

如果小于这个值就可以生长

# 第六章 图像的几何变换

## 图像几何变换

- 平移
  $$
  \left[\begin{array}{l}
  x \\
  y \\
  1
  \end{array}\right]=\left[\begin{array}{lll}
  1 & 0 & \Delta x \\
  0 & 1 & \Delta y \\
  0 & 0 & 1
  \end{array}\right]\left[\begin{array}{l}
  x_{0} \\
  y_{0} \\
  1
  \end{array}\right]
  $$
  
- 缩放
  $$
  \left[\begin{array}{l}
  x \\
  y \\
  1
  \end{array}\right]=\left[\begin{array}{ccc}
  f x & 0 & 0 \\
  0 & f y & 0 \\
  0 & 0 & 0
  \end{array}\right]\left[\begin{array}{l}
  x_{0} \\
  y_{0} \\
  1
  \end{array}\right]
  $$

- 镜像
  
  水平镜像
  $$
  \left[\begin{array}{l}
  x \\
  y \\
  1
  \end{array}\right]=\left[\begin{array}{ccc}
  -1 & 0 & \text { fWidth } \\
  0 & 1 & 0 \\
  0 & 0 & 1
  \end{array}\right]\left[\begin{array}{l}
  x_{0} \\
  y_{0} \\
  1
  \end{array}\right]
  $$
  垂直镜像
  $$
  \left[\begin{array}{l}
  x \\
  y \\
  1
  \end{array}\right]=\left[\begin{array}{ccc}
  1 & 0 & 0 \\
  0 & -1 & \text { fHeight } \\
  0 & 0 & 1
  \end{array}\right]\left[\begin{array}{c}
  x_{0} \\
  y_{0} \\
  1
  \end{array}\right]
  $$
  
- 旋转
  $$
  \left[\begin{array}{l}
  x \\
  y \\
  1
  \end{array}\right]=\left[\begin{array}{ccc}
  \cos \theta & \sin \theta & 0 \\
  -\sin \theta & \cos \theta & 0 \\
  0 & 0 & 1
  \end{array}\right]\left[\begin{array}{l}
  x_{0} \\
  y_{0} \\
  1
  \end{array}\right]
  $$





## 最近邻插值和线性插值

当图像放大之后，有的点就没有了，需要手动补充



设f(221, 396)=18，f(221, 397)=45，f(222, 396)=52，f (222, 397)=36,试分别用最邻近插值法和双线
性插值法，分别计算f(221.3, 396.7)的值。

解：分别设为ABCD

A=18

B=45

C=52

D=36

最近邻法一画图就出来了，明显离B最近。



双线性插值

这个玩意我个人觉得和灰度变换差不多，都是按比例进行估算。

首先绘图

![image-20220301211710119](img/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/image-20220301211710119.png)

现在已知A点是18，C是52。AE是0.3。想求E点的值还不是易如反掌。



那就是A点值加上AE长度乘上AC的差。

f(E) = 18+0.3*(f(c)-f(A)) = 18+0.3\*34=28.2

这就是一次插值。

f(F) =45+0.3*(36-54)=42.3



现在有了两个点之后，就可以进行第二次插值

28. 2+0.7*（F-E）=28.2+0.7\*(42.3-28.2)=38.07





# 第七章 频域处理

傅里叶变换可以把一个图像分解成若干个正弦和余弦函数



首先是背过这个玩意：
$$
F(u)=\frac{1}{N} \sum_{x=0}^{N-1} f(x) e^{-j 2 \pi u x / N}
$$

## 二维傅里叶变换

计算二维傅里叶变换，并求其频谱图
$$
\left[\begin{array}{ccc}
0 & 1 & 0 & 2 \\
0 & 3 & 0 & 4 \\
0 & 5 & 0 & 6 \\
0 & 7 & 0 & 8
\end{array}\right]
$$

![image-20220301211728367](img/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/image-20220301211728367.png)

在计算A的时候，从1开始逆时针旋转。

第一行每次旋转$\frac{0\pi}{2}$，所以4个都是1；第二行每次旋转$\frac{1\pi}{2}$，所以是${1,-j,-1,j}$；第三行每次旋转半圈，也就是$\frac{2\pi}{2}$；第四行旋转$\frac{3\pi}{2}$

$A = \frac{1}{\sqrt4} \left[\begin{array}{ccc}
1 & 1 & 1 & 1 \\
1 & -j & -1 & j \\
1 & -1 & 1 & -1 \\
1 & j & -1 & -j
\end{array}\right] $

之后进行矩阵乘法

$f(u,v)= AfA^T = \frac{1}{\sqrt4} \left[\begin{array}{ccc}
1 & 1 & 1 & 1 \\
1 & -j & -1 & j \\
1 & -1 & 1 & -1 \\
1 & j & -1 & -j
\end{array}\right]\left[\begin{array}{ccc}
0 & 1 & 0 & 2 \\
0 & 3 & 0 & 4 \\
0 & 5 & 0 & 6 \\
0 & 7 & 0 & 8
\end{array}\right]\frac{1}{\sqrt4}\left[\begin{array}{ccc}
1 & 1 & 1 & 1 \\
1 & -j & -1 & j \\
1 & -1 & 1 & -1 \\
1 & j & -1 & -j
\end{array}\right]  \\ = \left[\begin{array}{ccc}
9 & j & -9 & -j \\
2j-2 & 0 & 2-2j & 0 \\
-2 & 0 & 2 & 0 \\
-2-2j & 0 & 2+2j & 0
\end{array}\right]$

频谱图就是把所有的负号都忽略，带j的全部变成根号，j变成1

$\left[\begin{array}{ccc}
9 & 1 & 9 & 1 \\
2\sqrt2 & 0 & 2\sqrt2 & 0 \\
2 & 0 & 2 & 0 \\
2\sqrt2 & 0 & 2\sqrt2 & 0
\end{array}\right]$



## 证明

$$
\begin{array}{ll}
F(u, v)=\frac{1}{N} \sum_{x=0}^{N-1} \sum_{y=0}^{N-1} f(x, y) \exp \frac{-j 2 \pi(u x+v y)}{N} & u, v=0,1, \cdots, N-1 \\
f(x, y)=\frac{1}{N} \sum_{u=0}^{N-1} \sum_{v=0}^{N-1} F(u, v) \exp \frac{j 2 \pi(u x+v y)}{N} & x, y=0,1, \cdots, N-1
\end{array}
$$

思路是一样的，实际上本质就是对原函数变化，然后看对应的结果

比如线性性质
$$
F\left[a_{1} f_{1}(x, y)+a_{2} f_{2}(x, y)\right]=a_{1} F\left[f_{1}(x, y)\right]+a_{2} F\left[f_{2}(x, y)\right]
$$

<img src="img/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/image-20220306000320836.png" alt="image-20220306000320836" style="zoom: 25%;" />

# 第八章 数学形态学及其应用





![image-20220309220438022](img/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/image-20220309220438022.png)

- 腐蚀

  腐蚀应用举例-使用腐蚀消除图像的细节部分，产生滤波器的作用

  ![image-20220301211746223](img/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/image-20220301211746223.png)

- 膨胀

  膨胀应用-桥接文字裂缝

  ![image-20220301211758114](img/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/image-20220301211758114.png)



- 开运算：先腐蚀后膨胀

  就是在图形内部滚一圈

  ![image-20220301212021425](img/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/image-20220301212021425.png)

- 闭运算：先膨胀后腐蚀

  在图像外部滚一圈

  ![image-20220301212029843](img/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/image-20220301212029843.png)

# 第十章 图像特征与理解

## 孔

 在0像素的连接成分中，如果存在和图像外围的1行或1列的0像素不相连接的成分，则称之为**孔**。
            不包含孔的1像素连接成分叫做**单连接成分**；
            含有孔的1像素连接成分叫做**多重连接成分**。

![image-20220309221002125](img/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/image-20220309221002125.png)

## 欧拉数的计算

就是图像的块数减去孔数

![image-20220301212010502](img/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/image-20220301212010502.png)

这四个字母，B只有一块，但是有两个孔。所以为1-2 =-1

i有两块，但是没有孔，所以为2-0=2

r有一块，而且没有孔，1-0=1

d 1-1=0



## 像素间的关系

- 孤立点

  周围全都没有点

- 内部点

  周围全是点

- 边界点

  有点，但是周围并不全是点
  
- 背景点

  没有点的地方都叫背景点

  

![image-20220301211952688](img/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/image-20220301211952688.png)

## 距离

![image-20220301211939418](img/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/image-20220301211939418.png)

# 第十一章 图像压缩编码

## Huffman编码

首先对信源概率从大到小排序， 选出最小的两个概率（0.04和0.05），相加得0.09，与其他概率组成新的概率集合{0.40， 0.18， 0.10， 0.10， 0.07， 0.06， 0.09}。

![image-20220301211921492](img/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/image-20220301211921492.png)

小的赋值1，大的赋值0

**最后一定不要忘记在最左边把码字写出来。**

然后***反向排列***！！！！



![image-20220310103204039](img/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/image-20220310103204039.png)

![image-20220310103216162](img/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/image-20220310103216162.png)



## 香农-范诺编码

1. 把编码**从大到小**排序

2. 计算一个码字长度，长度为$-log_2(P_i)$到$-log_2(P_i)+1$

   比如$-log_2(0.4) = 1.32$，所以码字长度为1.32到2.32，娶个整就是2。

3. 计算累加概率

4. 把累加概率转为二进制，长度就是之前算的码字长度

![image-20220301211831392](img/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/image-20220301211831392.png)

## 二分香农-范诺编码

1. 把概论从大到小排列
2. 尽可能把这些概论平均分。**说白了就是分完之后的两个值，小的那个要尽可能大。**
3. **上面赋值0，下面赋值1**
4. 从左到右，**顺序编码**

![image-20220301211816496](img/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/image-20220301211816496.png)



# Matlab

## 矩阵

- 创建矩阵

  ```matlab
  a =[1,2,3;4,5,6;7,8,9]
  ```

- 矩阵转置

  ```matlab
  a'
  ```




假设$A=\left[\begin{array}{ccc}
1 & 2 & 3 \\
4 & 5 & 6 \\
7 & 8 & 9
\end{array}\right]$

```matlab
A(:) %147258369,按照列的顺序打印
A(:,:) %按照123的顺序打印
A(:,1)  %打印每一行的第一列
A(2:4) %打印这个矩阵的第2到4个元素，注意！这里中间没有逗号，所以当作一维处理。也就是1 4 7 2的顺序排列。
A(:,2:3)  %打印每一行的2到3列
A([4,6]) %打印一维矩阵的4和6号元素
A(:, end:-1:2) %从最后一列开始打印，打印到第2列，每次间隔1列
```





```matlab
矩阵转置：A’
矩阵加和减： A+B, A-B
矩阵乘法：A*B
矩阵除法：A\B=A-1*B，A/B=A*B-1
矩阵的乘方 ：a^2
两个矩阵相应元素相乘：A.*B
两个矩阵相应元素相除：A./B

```

## 图像处理

```matlab
image = imread('peppers.png');
image = rgb2gray(image);
imshow(image);
[row,col] = size(image);

imhist(image)   %显示直方图
imadjust(I,[0.3 0.7]) %灰度变换






%对一幅灰度图像进行傅里叶变换，显示其频谱图；
I=imread('test.png');
subplot(1,2,1);
imshow(I);
title('原图像');
s=fftshift(fft2(I));
subplot(1,2,2);
imshow(abs(s),[]);
title('图像傅里叶变换所得频谱');
```

```matlab

%区域生长法
function [g,NR,SI,TI]=regiongrow(f,S,T)
f=double(f);
if numel(S)==1
    SI=f==S;
    S1=S;
else
    SI=bwmorph(3,'shrink',Inf);
    J=find(SI);
    S1=f(J);
end
TI=false(size(f));
for K=1:length(S1)
    seedvalue=S1(K);
    S=abs(f-seedvalue)<=T;
    TI=TI|S;
end
[g,NR]=bwlabel(imreconstruct(SI,TI));
end

%迭代阈值法

T1=0.5*(double(min(image(:)))+double(max(image(:))));%将T1设为最大灰度与最小灰度的中间值。
d=false;
while~d
    g=image>=T1;
    T2=0.5*(mean(image(g))+mean(image(~g)));%计算新的阈值T2= (1+2)/2；
    d=abs(T1-T2)<0.5;
    T1=T2;
end

% 根据最佳阈值进行图像分割
level=T2/255;
BW=im2bw(image,level);
subplot(121),imshow(image);title('原图');%显示原图
subplot(122),imshow(BW);title('迭代阈值分割') ;%显示处理后的图像



[g,NR,SI,TI] = regiongrow(image,[4,5],1)
subplot(121),imshow(image);title('原图');%显示原图
subplot(122),imshow(g);title('质心生长法') ;%显示处理后的图像

%
```

