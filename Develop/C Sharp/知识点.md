

# 匿名类型

 **为什么需要匿名类型？**

1. **避免创建额外的类**：
    - 如果只是**临时使用**某个数据结构，而**不需要长期维护**，匿名类型可以减少不必要的代码。
2. **代码更简洁**：
    - 无需显式创建类或结构体，代码更加直观。
3. **适用于 LINQ 查询**：
    - 匿名类型在 **LINQ** 查询中特别有用，允许我们**动态返回多个字段**，而无需创建单独的类。

```c#
var person = new { Name = "Alice", Age = 25, Country = "USA" }; Console.WriteLine($"姓名: {person.Name}, 年龄: {person.Age}, 国家: {person.Country}");
```



```c#
var person = new { Name = "Alice", Age = 25 };
// person.Age = 26; // ❌ 报错：属性是只读的
```


# ref关键字

- ref用于给方法一个可以修改的值,通常是值类型。使它可以像引用类型一样被方法内部修改

```C#
using System;

class Program
{
    static void UpdateValue(ref int number)
    {
        number += 10; // 修改传入的参数
        Console.WriteLine($"方法内部: number = {number}");
    }

    static void Main()
    {
        int myNumber = 5;
        Console.WriteLine($"调用前: myNumber = {myNumber}");
        
        UpdateValue(ref myNumber); // 传递变量的引用
        
        Console.WriteLine($"调用后: myNumber = {myNumber}");
    }
}
//调用前: myNumber = 5 
//方法内部: number = 15 
//调用后: myNumber = 15

```
- **参数必须先初始化**：`ref` 参数在传递给方法之前，必须**已经赋值**，否则编译器会报错。
- **适用于值类型和引用类型**：可以用于 `int`、`float` 这些**值类型**，也可以用于 `class` 这种**引用类型**。



# out关键字

- 使用 `out` 可以传递多个返回值
```c#
using System;

class Program
{
    static void Divide(int dividend, int divisor, out int quotient, out int remainder)
    {
        quotient = dividend / divisor;
        remainder = dividend % divisor;
    }

    static void Main()
    {
        int result, remainder;
        
        // 这里的 result 和 remainder 变量不需要初始化
        Divide(10, 3, out result, out remainder);

        Console.WriteLine($"商: {result}, 余数: {remainder}");
    }
}
//商: 3, 余数: 1
```

-  **`out` 非常适合在 `TryGetValue` 方法中使用**

在 C# 的 `Dictionary<TKey, TValue>` 中，`TryGetValue` 方法用于**安全获取值**，如果键存在，就返回 `true`，并通过 `out` 变量返回对应的值；如果键不存在，则返回 `false`，并不会抛出异常。
```c#
using System;
using System.Collections.Generic;

class Program
{
    static void Main()
    {
        // 创建一个 Dictionary
        Dictionary<string, int> scores = new Dictionary<string, int>
        {
            { "Alice", 90 },
            { "Bob", 85 },
            { "Charlie", 78 }
        };

        // 查找 Bob 的成绩
        if (scores.TryGetValue("Bob", out int bobScore))
        {
            Console.WriteLine($"Bob 的成绩是: {bobScore}");
        }
        else
        {
            Console.WriteLine("未找到 Bob 的成绩");
        }

        // 查找 Tom 的成绩（不存在）
        if (scores.TryGetValue("Tom", out int tomScore))
        {
            Console.WriteLine($"Tom 的成绩是: {tomScore}");
        }
        else
        {
            Console.WriteLine("未找到 Tom 的成绩");
        }
    }
}

```


- `out` 变量允许调用前未初始化，也可以直接在out后面声明这个变量
```c#
using System;

class Program
{
    static void GetRandomNumber(out int number)
    {
        number = new Random().Next(1, 100); // 方法内部必须赋值
    }

    static void Main()
    {
        int myNumber; // 变量未初始化
        GetRandomNumber(out myNumber); // 传递 out 变量
		//GetRandomNumber(out int myNumber);//直接声明
        Console.WriteLine($"随机数: {myNumber}");
    }
}

```


# 扩展方法

- 扩展方法可以给**第三方库**或**系统类**（如 `string`, `List<T>`）增加新功能，而**不需要继承或修改源代码**。
- - **使用 `this` 关键字**：扩展方法的第一个参数前必须加上 `this`，指定该方法属于哪个类型。
- **必须定义在 `static` 类中**：扩展方法所在的类**必须是静态类**，方法本身**也必须是静态方法**

```c#
using System.Collections.Generic;
public static class CardExtensions
{
    /// <summary>
    /// 类型拓展,根据卡牌名称获取卡牌列表
    /// </summary>
    /// <param name="cards">要搜索的卡牌列表</param>
    /// <param name="name">要搜索的卡牌名称</param>
    /// <returns>返回所有符合名称的卡牌列表</returns>
    public static List<Card> GetCardsByName(this List<Card> cards, string name)
    {
        return cards.FindAll(card => card.cardData.cardName == name);
    }
}
```
使用：
```c#
 if(thisCard.trueEffectCards.GetCardsByName("道路").Count==1){
                        Debug.Log("只有一个道路");
                        thisCard.trueEffectCards.GetCardsByTag(CardTag.双足生物).ChangeValue(1,thisCard);
                    }
```