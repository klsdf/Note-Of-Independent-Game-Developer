## 单例模式

用来处理DontDestroyOnLoad

```c#
public class GameManager : MonoBehaviour
{
	private static GameManager _instance;   // 单例
	public GameManager GameManagerInstance
    {
        get { return _instance; }
    }
    void Awake()
    {
        if (_instance != null)
        {
        	//这里一定要是销毁this.gameObject
            Destroy(this.gameObject);
            return;
        }
        //这句话只执行一次，第二次上面return了
        _instance = this;
    }
}

```



不继承mono的

```c#
public class Test 
{


    private static Test _instance;
    //单例模式
    public static Test Instance
    {
        get
         {
            if (_instance == null) {
                _instance = new Test();
            }
            return _instance;

        }
    }
}
```



继承mono的

```c#
public class UIController:MonoBehaviour
{

    public static UIController Instance;
 

    private void Awake()
    {
        Instance = this;
    }

    public void changeRestBalls()
    {

    }
}
```

虽然直接在awake中写很方便，但是存在一个问题。那就是awake的调用顺序是不一定的，在脚本中，如果awake时出现了单例互相调用的情况，那么有可能其他的单例还没有初始化，因此可以用下面的方法进行改进。



```c#
static Test instance;
public static Test Instance
{
    get
    {
        if(instance == null)
        {
            instance = FindObjectOfType<Test>();
           
        }
         return instance;
    }
}
```

## 状态模式


```

```



## 观察者模式

当对象之间存在一对多的依赖关系时，其中一个对象的状态发生改变，所有依赖它的对象都会收到通知，这就是观察者模式。

在观察者模式中，只有两种主体：目标对象 (**Object**) 和 观察者 (**Observer**)。



```c#
using System.Collections;
using System.Collections.Generic; 
using UnityEngine;
using System;

public class ObserveMode : MonoBehaviour
{
    //玩家死亡之后的事件，需要被观察
    public static event Action playerDeadEvent;

    private void OnDestroy()
    {
        playerDeadEvent?.Invoke();
    }
}

```





```c#
//敌人
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Enemy : MonoBehaviour
{

    //在开始就观察玩家的死亡事件
    void Start()
    {
        ObserveMode.playerDeadEvent += () =>
        {
            print("玩家死了！！");
        };
    }

}

```





接下来来设计一个更加同样的





## 组合模式

## 发布者订阅者模式

和观察者模式很像，但是要注意！！！

观察者模式实际上是**松耦合(loosely coupled)**。也就是说，玩家死亡之后会直接通知所有的敌人。这个实际上还是有很强的耦合性的。

但是发布者订阅者模式中，发布者和订阅者并不会直接通信！而是通过一个中间商进行通信。

发布者只需告诉中间商，我要发的消息，topic是AAA；

订阅者只需告诉中间商，我要订阅topic是AAA的消息；即可。





```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System;

public enum 事件类型
{
    玩家死亡,
    敌人死亡
}


public class 订阅者发布者模式 : MonoBehaviour
{
    //用来维护所有的事件
    private static Dictionary<事件类型, Delegate> 发布事件字典 = new Dictionary<事件类型, Delegate>();

    private static void  订阅前的检查(事件类型 事件, Delegate 回调函数)
    {
        if (!发布事件字典.ContainsKey(事件))
        {
            发布事件字典.Add(事件, null);
        }
        Delegate 已经存储的回调函数 = 发布事件字典[事件];
        if (已经存储的回调函数 != null && 已经存储的回调函数.GetType() != 回调函数.GetType())
        {
            throw new Exception(string.Format("尝试为事件{0}添加不同类型的委托，当前事件所对应的委托是{1}，要添加的委托类型为{2}", 事件, 已经存储的回调函数.GetType(), 回调函数.GetType()));
        }
    }

    //无参数的订阅与发布
    public static void 订阅(事件类型 事件, Action 回调函数)
    {
        订阅前的检查(事件, 回调函数);
        发布事件字典[事件] = (Action)发布事件字典[事件] + 回调函数;//用多播直接存储回调函数
    }

    public static void 发布(事件类型 事件)
    {

        Delegate 回调函数;
        if (发布事件字典.TryGetValue(事件, out 回调函数))
        {
            ((Action)回调函数)();
        }
    }



    //一个参数的订阅与发布

    public static void 订阅<T>(事件类型 事件, Action<T> 回调函数)
    {
        订阅前的检查( 事件,  回调函数);
        发布事件字典[事件] = (Action<T>)发布事件字典[事件] + 回调函数;//用多播直接存储回调函数
    }

    public static void 发布<T>(事件类型 事件,T 参数)
    {

        Delegate 回调函数;
        if (发布事件字典.TryGetValue(事件, out 回调函数))
        {
            ((Action<T>)回调函数)(参数);
        }
    }

}

```



```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class 订阅者 : MonoBehaviour
{

    void Start()
    {
        订阅者发布者模式.订阅<string>(事件类型.玩家死亡, (msg) =>{
            print("收到事件通知！"+msg);
        });
    }

}

```





```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class 发布者 : MonoBehaviour
{

    private void OnDisable()
    {
        订阅者发布者模式.发布(事件类型.玩家死亡,"GGGG");

    }
}

```



## 享元模式



