## 单例模式

用来处理DontDestroyOnLoad

```c#
public class GameManager : MonoBehaviour
{
	private static GameManager _instance;   // 单例
	public GameManager GameManagerInstance
    {
        get { return _instance; }
    }
    void Awake()
    {
        if (_instance != null)
        {
        	//这里一定要是销毁this.gameObject
            Destroy(this.gameObject);
            return;
        }
        //这句话只执行一次，第二次上面return了
        _instance = this;
    }
}

```



不继承mono的

```c#
public class Test 
{


    private static Test _instance;
    //单例模式
    public static Test Instance
    {
        get
         {
            if (_instance == null) {
                _instance = new Test();
            }
            return _instance;

        }
    }
}
```



继承mono的

```c#
public class UIController:MonoBehaviour
{

    public static UIController Instance;
 

    private void Awake()
    {
        Instance = this;
    }

    public void changeRestBalls()
    {

    }
}
```

虽然直接在awake中写很方便，但是存在一个问题。那就是awake的调用顺序是不一定的，在脚本中，如果awake时出现了单例互相调用的情况，那么有可能其他的单例还没有初始化，因此可以用下面的方法进行改进。



```c#
static Test instance;
public static Test Instance
{
    get
    {
        if(instance == null)
        {
            instance = FindObjectOfType<Test>();
           
        }
         return instance;
    }
}
```

## 状态模式


```

```



## 观察者模式

当对象之间存在一对多的依赖关系时，其中一个对象的状态发生改变，所有依赖它的对象都会收到通知，这就是观察者模式。

在观察者模式中，只有两种主体：目标对象 (**Object**) 和 观察者 (**Observer**)。



```c#
using System.Collections;
using System.Collections.Generic; 
using UnityEngine;
using System;

public class ObserveMode : MonoBehaviour
{
    //玩家死亡之后的事件，需要被观察
    public static event Action playerDeadEvent;

    private void OnDestroy()
    {
        playerDeadEvent?.Invoke();
    }
}

```





```c#
//敌人
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Enemy : MonoBehaviour
{

    //在开始就观察玩家的死亡事件
    void Start()
    {
        ObserveMode.playerDeadEvent += () =>
        {
            print("玩家死了！！");
        };
    }

}

```





接下来来设计一个更加同样的



## 组合模式

## 发布者订阅者模式

和观察者模式很像，但是要注意！！！

观察者模式实际上是**松耦合(loosely coupled)**。也就是说，玩家死亡之后会直接通知所有的敌人。这个实际上还是有很强的耦合性的。

但是发布者订阅者模式中，发布者和订阅者并不会直接通信！而是通过一个中间商进行通信。

发布者只需告诉中间商，我要发的消息，topic是AAA；

订阅者只需告诉中间商，我要订阅topic是AAA的消息；即可。





```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System;

public enum 事件类型
{
    玩家死亡,
    敌人死亡
}


public class 订阅者发布者模式 : MonoBehaviour
{
    //用来维护所有的事件
    private static Dictionary<事件类型, Delegate> 发布事件字典 = new Dictionary<事件类型, Delegate>();

    private static void  订阅前的检查(事件类型 事件, Delegate 回调函数)
    {
        if (!发布事件字典.ContainsKey(事件))
        {
            发布事件字典.Add(事件, null);
        }
        Delegate 已经存储的回调函数 = 发布事件字典[事件];
        if (已经存储的回调函数 != null && 已经存储的回调函数.GetType() != 回调函数.GetType())
        {
            throw new Exception(string.Format("尝试为事件{0}添加不同类型的委托，当前事件所对应的委托是{1}，要添加的委托类型为{2}", 事件, 已经存储的回调函数.GetType(), 回调函数.GetType()));
        }
    }

    //无参数的订阅与发布
    public static void 订阅(事件类型 事件, Action 回调函数)
    {
        订阅前的检查(事件, 回调函数);
        发布事件字典[事件] = (Action)发布事件字典[事件] + 回调函数;//用多播直接存储回调函数
    }

    public static void 发布(事件类型 事件)
    {

        Delegate 回调函数;
        if (发布事件字典.TryGetValue(事件, out 回调函数))
        {
            ((Action)回调函数)();
        }
    }



    //一个参数的订阅与发布

    public static void 订阅<T>(事件类型 事件, Action<T> 回调函数)
    {
        订阅前的检查( 事件,  回调函数);
        发布事件字典[事件] = (Action<T>)发布事件字典[事件] + 回调函数;//用多播直接存储回调函数
    }

    public static void 发布<T>(事件类型 事件,T 参数)
    {

        Delegate 回调函数;
        if (发布事件字典.TryGetValue(事件, out 回调函数))
        {
            ((Action<T>)回调函数)(参数);
        }
    }

}

```



```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class 订阅者 : MonoBehaviour
{

    void Start()
    {
        订阅者发布者模式.订阅<string>(事件类型.玩家死亡, (msg) =>{
            print("收到事件通知！"+msg);
        });
    }

}

```





```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class 发布者 : MonoBehaviour
{

    private void OnDisable()
    {
        订阅者发布者模式.发布(事件类型.玩家死亡,"GGGG");

    }
}

```



## 享元模式



在Unity中实现享元模式可以显著优化内存使用，特别是在大量重复对象的场景中（如粒子系统、敌人管理、树木渲染等）。以下是一个享元模式模板的完整实现：


享元模式包括：

- **享元工厂（Flyweight Factory）：** 用于管理和复用享元对象。
- **享元接口（Flyweight）：** 定义共享对象的通用接口。
- **具体享元类（Concrete Flyweight）：** 实现享元接口，表示可共享的对象。
- **非共享具体享元（Unshared Flyweight）：** 表示不共享的状态。


```c#
using System.Collections.Generic;
using UnityEngine;

// Flyweight Interface
public interface IEnemy
{
    void Display(Vector3 position);
}

// Concrete Flyweight
public class EnemyType : IEnemy
{
    private string _name; // 享元内部共享的状态
    private Color _color;

    public EnemyType(string name, Color color)
    {
        _name = name;
        _color = color;
    }

    public void Display(Vector3 position)
    {
        // 在场景中展示敌人
        GameObject enemy = GameObject.CreatePrimitive(PrimitiveType.Cube);
        enemy.transform.position = position;
        enemy.name = _name;
        enemy.GetComponent<Renderer>().material.color = _color;

        Debug.Log($"Spawned {_name} at {position}");
    }
}

// Flyweight Factory
public class EnemyFactory
{
    private Dictionary<string, EnemyType> _enemyTypes = new Dictionary<string, EnemyType>();

    public IEnemy GetEnemyType(string name, Color color)
    {
        if (!_enemyTypes.ContainsKey(name))
        {
            _enemyTypes[name] = new EnemyType(name, color);
            Debug.Log($"Created new EnemyType: {name}");
        }

        return _enemyTypes[name];
    }
}

// Client
public class EnemySpawner : MonoBehaviour
{
    private EnemyFactory _factory;

    void Start()
    {
        _factory = new EnemyFactory();

        // Spawning enemies
        SpawnEnemy("Orc", Color.green, new Vector3(0, 0, 0));
        SpawnEnemy("Goblin", Color.red, new Vector3(2, 0, 0));
        SpawnEnemy("Orc", Color.green, new Vector3(4, 0, 0)); // Reuses the "Orc" type
        SpawnEnemy("Goblin", Color.red, new Vector3(6, 0, 0)); // Reuses the "Goblin" type
    }

    private void SpawnEnemy(string name, Color color, Vector3 position)
    {
        IEnemy enemy = _factory.GetEnemyType(name, color);
        enemy.Display(position);
    }
}
```




